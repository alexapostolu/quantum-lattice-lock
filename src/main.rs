use rand::Rng;
use rand::rngs::OsRng;

/*
 * Generates two trivial private basis vectors for a 'n' dimensional lattice.
 *
 * The trivial vectors are independant unit vectors that are generated by
 * converting a random angle from polar form into rectangular form.
 *
 * @returns both trivial private basis vectors. 
 */
fn generate_private_vectors(dimensions: u16) -> Vec<Vec<f64>>
{
	let mut rng = OsRng;

	let mut private_vectors: Vec<Vec<f64>> = (0..dimensions)
        .map(|_| {
            (0..dimensions)
                .map(|_| rng.gen_range(-10.0..=10.0))
                .collect()
        })
        .collect();

	for v in private_vectors.iter_mut() {
        let magnitude = (v.iter().map(|x| x.powi(2)).sum::<f64>()).sqrt();
		if magnitude > 0.0 {
			for x in v.iter_mut() {
				*x /= magnitude;
			}
		}
    }

	return private_vectors;
}

/*
 * Generates two non trivial basis vectors for a lattice specificed by the
 * given private trivial basic vectors.
 *
 * @returns both non trivial public vectors
 */
// fn generate_public_vectors(&(::Vec<i32>, ::Vec<i32>))
// {

// }

// /*
//  * Encodes the binary representation of the message amongst the lattice
//  * specified by the public basis vectors.
//  *
//  * @returns the position
//  */
// fn encode_message(&(::Vec<i32>, ::Vec<i32>))
// {

// }

fn main()
{
	let private_vectors = generate_private_vectors(5);
	println!("{:?}", private_vectors);
}